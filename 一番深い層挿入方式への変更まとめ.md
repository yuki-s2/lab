# 🔄 一番深い層挿入方式への変更完了

## ✅ **変更内容**

### **1. PartItem.tsx**

- `{{content}}`プレースホルダー方式から`insertContentToDeepestElement`使用に変更
- シンプルな関数構造に戻した
- ネストした子パーツの表示は`children`propsで対応

### **2. useParts.tsx**

- **addPart**: 保存時に`insertContentToDeepestElement`でコンテンツを挿入
- **updatePart**: 更新時にフレームテンプレートを再取得してコンテンツを挿入
- データベースには処理済みの完全なHTMLが保存される

### **3. Assemble.tsx**

- HTML生成機能で`insertContentToDeepestElement`を使用
- ネストした子パーツのHTMLを親の一番深い層に挿入
- 外側フレームテンプレートにも対応

## 🎯 **動作の違い**

### **以前 ({{content}}方式)**

```javascript
// フレームテンプレート
"<table><tr><td>{{content}}</td></tr></table>";

// 保存時
frame: "<table><tr><td>{{content}}</td></tr></table>";
content: "Hello World";

// 表示時
("<table><tr><td>Hello World</td></tr></table>");
```

### **現在 (一番深い層方式)**

```javascript
// フレームテンプレート
"<table><tr><td></td></tr></table>";

// 保存時（一番深い層に挿入）
frame: "<table><tr><td>Hello World</td></tr></table>";
content: "Hello World";

// 表示時
("<table><tr><td>Hello World</td></tr></table>");
```

## 🔧 **技術的な変更**

### **insertContentToDeepestElement関数**

```typescript
export function insertContentToDeepestElement(
  frame: string,
  content: string | null
): string {
  const parser = new DOMParser();
  const doc = parser.parseFromString(frame, "text/html");
  const root = doc.body.firstElementChild;

  const findDeepest = (node: Element): Element => {
    const firstChild = Array.from(node.children).find(
      (child) => child.nodeType === Node.ELEMENT_NODE
    );
    return firstChild ? findDeepest(firstChild) : node;
  };

  if (root) {
    const target = findDeepest(root);
    target.innerHTML = content || "";
    return root.outerHTML;
  }
  return frame;
}
```

## 🎨 **メリット**

1. **シンプルな構造**: プレースホルダー管理が不要
2. **確実な挿入**: DOMパーサーで正確な最深層を特定
3. **ネスト対応**: 子パーツのHTMLを親の最深層に配置
4. **後方互換性**: 既存データとの互換性を維持

## 🚀 **使用方法**

1. **フレーム作成**: `{{content}}`なしの素のHTMLテンプレート
2. **パーツ作成**: コンテンツが自動的に最深層に挿入
3. **ネスト**: 子パーツのHTMLが親の最深層に配置
4. **HTML生成**: 完全なネスト構造のHTMLを出力

---

**🎉 完了！** より直感的で確実なコンテンツ挿入方式になりました。
